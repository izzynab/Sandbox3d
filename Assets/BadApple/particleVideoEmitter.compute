// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSGenerate

 // Particle's data
struct Particle
{
	float3 position;
	float3 velocity;
	float life;
	float3 color;
	float size;
};

// Particle's data, shared with the shader
RWStructuredBuffer<Particle> ParticleBuffer;

RWStructuredBuffer<int2> ActivePositions;

int NumberOfActivePixels;
int CountOfActivePixels;

float speed;
float lifetime;
float deltaTime;
float mainParticleSize;
float otherParticleSize;


uint rng_state;

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

//rand from -1 to 1
float rand_xor()
{
	return float(rand_xorshift()) * (1.0 / 4294967296.0) *2 - 1;
}


[numthreads(64, 1, 1)]
void CSGenerate(uint3 id : SV_DispatchThreadID)
{
	float2 spawnPosition;

	if(id.x <= NumberOfActivePixels)
	{
		
		spawnPosition = ActivePositions[id.x%NumberOfActivePixels];
		ParticleBuffer[id.x].position = float3(spawnPosition.x, spawnPosition.y, 0);
		ParticleBuffer[id.x].color = float3(1.0,0.5,0.0);
		ParticleBuffer[id.x].size = mainParticleSize;

		//ParticleBuffer[id.x].life -= deltaTime;
		//float3 dir = normalize(float3(rand_xor()-0.5,rand_xor()-0.5,rand_xor()-0.5));

		//ParticleBuffer[id.x].velocity = dir*speed*(rand_xor()+1);
		//ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity*deltaTime;
	
	}
	//else
	{
		return;
		spawnPosition = ActivePositions[id.x%NumberOfActivePixels];
		
		ParticleBuffer[id.x].position = float3(spawnPosition.x, spawnPosition.y, 0);
		ParticleBuffer[id.x].color = float3(0.2,0.5,1.0);
		ParticleBuffer[id.x].size = otherParticleSize;

		ParticleBuffer[id.x].life -= deltaTime;
		float3 dir = normalize(float3(rand_xor()-0.5,rand_xor()-0.5,rand_xor()-0.5));
		
		ParticleBuffer[id.x].velocity = dir*speed*(rand_xor()+1);
		ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity*deltaTime;

		if (ParticleBuffer[id.x].life <= 0)
			{
				// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
				rng_state = id.x;
				float f0 = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
				float f1 = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
				float2 normalF2 = normalize(float2(f0, f1)) * 0.8f;
				normalF2 *= float(rand_xorshift()) * (1.0 / 4294967296.0);
		
				//ParticleBuffer[id.x].position = float3(spawnPosition.x, spawnPosition.y, 0);
				//ParticleBuffer[id.x].position = float3(0, 0, 0);
				ParticleBuffer[id.x].life = lifetime;
				ParticleBuffer[id.x].velocity = float3(0, 0,0);
			}

	}
	

	//if (ParticleBuffer[id.x].life <= 0)
	//	{
	//		// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
	//		rng_state = id.x;
	//		float f0 = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
	//		float f1 = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
	//		float2 normalF2 = normalize(float2(f0, f1)) * 0.8f;
	//		normalF2 *= float(rand_xorshift()) * (1.0 / 4294967296.0);
	//
	//		ParticleBuffer[id.x].position = float3(spawnPosition.x, spawnPosition.y, 0);
	//		ParticleBuffer[id.x].position = float3(0, 0, 0);
	//		ParticleBuffer[id.x].life = lifetime;
	//		ParticleBuffer[id.x].velocity = float3(0, 0,0);
	//	}

}
