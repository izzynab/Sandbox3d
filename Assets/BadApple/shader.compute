// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInit
#pragma kernel CSMain
#pragma kernel CSGenerate

RWTexture2D<float4> Result;

Texture2D<float4> ClipTexture;
SamplerState sampler_ClipTexture;

RWStructuredBuffer<float4> Positions;
 
RWStructuredBuffer<int> ResultBuffer;

float ResolutionScale;
float ColorOffset;
float ClipWidth;

[numthreads(1, 1, 1)]
void CSInit(uint3 id : SV_DispatchThreadID)
{
    //ResultBuffer[0] = 0;
}
 
 
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    ClipTexture.Sample(sampler_ClipTexture, id.xy);
    uint4 col = ClipTexture[id.xy*ResolutionScale];

    if(col.r > ColorOffset)
    {
        //InterlockedAdd(ResultBuffer[0], 1);
        Result[id.xy] = float4(1,1,1,1);
    }
    else Result[id.xy] = float4(0,0,0,1);
}

[numthreads(8, 8, 1)]
void CSGenerate(uint3 id : SV_DispatchThreadID)
{
    ClipTexture.Sample(sampler_ClipTexture, id.xy);
    uint4 col = ClipTexture[id.xy*ResolutionScale];


    if(col.r > ColorOffset)
    {
         //InterlockedAdd(ResultBuffer[0], 1);
         Positions[id.x + id.y * ClipWidth] = float4(id.x,id.y,0,1);         
         Result[id.xy] = float4(1,1,1,1);
    }
    else 
    {
        Positions[id.x + id.y * ClipWidth] = float4(0,0,0,0);
        Result[id.xy] = float4(0,0,0,0);
    }

}

